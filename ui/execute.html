<!doctype html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <title>Program – eksekvering</title>
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial; padding:20px; background:#f5f6fb; color:#1b1f2b; }
    h1 { margin:0 0 8px; font-size:24px; }
    p.muted { color:#666; font-size:13px; }
    .active-profile { margin:0 0 12px; font-size:13px; color:#333; }
    .active-profile strong { color:#000; }
    .layout { display:grid; grid-template-columns: 3fr 1fr; gap:18px; }
    section { background:#fff; border:1px solid #e0e0f4; border-radius:12px; padding:16px; margin-bottom:16px; box-shadow:0 4px 12px rgba(10,20,60,0.05); }
    section h2 { margin:0 0 10px; font-size:18px; }
    .control-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:12px; }
    label { display:block; font-size:12px; color:#4a4e66; text-transform:uppercase; letter-spacing:0.05em; margin-bottom:4px; }
    select, input[type="number"] { width:100%; padding:8px; font-size:14px; border:1px solid #cfd5ea; border-radius:8px; }
    .session-buttons { display:flex; flex-wrap:wrap; gap:8px; }
    .session-buttons button { padding:8px 14px; border:1px solid #ccd7ef; border-radius:20px; background:#fff; cursor:pointer; font-size:13px; }
    .session-buttons button.active { background:#0b72ff; color:#fff; border-color:#0b72ff; }
    table { width:100%; border-collapse:collapse; margin-top:12px; }
    th, td { border:1px solid #e5e8f5; padding:8px; font-size:13px; text-align:left; vertical-align:top; }
    th { background:#f3f5fb; font-size:12px; text-transform:uppercase; letter-spacing:0.03em; color:#495169; }
    .time-control { display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
    input[type="range"] { flex:1; }
    .time-status { margin-top:8px; font-size:13px; }
    .notes-list { margin:8px 0 0; padding-left:18px; font-size:13px; }
    .notes-list li { margin-bottom:4px; }
    .summary { background:#111529; color:#fff; border-radius:12px; padding:18px; position:sticky; top:20px; }
    .summary h2 { margin-top:0; color:#fff; }
    .summary p, .summary li { color:#cfd6ff; font-size:13px; }
    .hidden { display:none; }
    .badge { display:inline-flex; align-items:center; gap:6px; background:#eef3ff; border-radius:999px; padding:4px 10px; font-size:12px; color:#1c2b55; margin-right:8px; }
    .warning { color:#a20000; font-weight:600; }
    .session-note { background:#f8f9ff; border-left:3px solid #0b72ff; padding:10px; border-radius:8px; font-size:13px; color:#3b4060; margin-top:12px; }
    .warmup-banner { background:#fff4e5; border:1px solid #ffd9b3; border-radius:8px; padding:10px; margin:12px 0; font-size:13px; color:#7a4b00; display:flex; gap:10px; align-items:center; }
    .warmup-banner strong { font-size:14px; }
    .warmup-plan { background:#fff; border:1px solid #f6d9b7; border-radius:8px; padding:10px; margin-bottom:12px; }
    .warmup-plan ul { margin:8px 0 0; padding-left:18px; font-size:13px; color:#4a3b24; }
    .warmup-plan li { margin-bottom:4px; }
    .warmup-equip { font-size:12px; color:#7a4b00; }
    .rest-editors { display:grid; grid-template-columns:repeat(auto-fit,minmax(130px,1fr)); gap:6px; font-size:12px; color:#3b4263; }
    .rest-editors label { display:flex; flex-direction:column; gap:3px; text-transform:none; letter-spacing:normal; font-weight:600; }
    .rest-editors input { width:100%; padding:6px; border:1px solid #cfd5ea; border-radius:6px; font-size:12px; }
    .superset-note { font-size:12px; color:#7a0b2b; margin-top:6px; font-weight:600; }
    .runner-section { margin-top:18px; background:#fff; border:1px solid #e0e0f4; border-radius:12px; padding:16px; box-shadow:0 4px 12px rgba(17,26,66,0.05); }
    .runner-section h2 { margin:0 0 8px; }
    .runner-status { display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:12px; font-size:14px; color:#2b3051; }
    .runner-timer { font-size:24px; font-weight:600; color:#121a3f; }
    .runner-controls { display:flex; flex-wrap:wrap; gap:10px; margin-top:12px; }
    .runner-controls button { border:1px solid #d8def4; background:#fff; padding:8px 14px; border-radius:20px; cursor:pointer; font-size:13px; }
    .runner-controls button:disabled { opacity:0.4; cursor:not-allowed; }
    .runner-eval { margin-top:16px; border-top:1px solid #e5e8f5; padding-top:12px; }
    .runner-eval label { display:block; margin-bottom:6px; font-size:13px; color:#333; }
    .runner-eval textarea { width:100%; padding:8px; border:1px solid #cfd5ea; border-radius:6px; font-size:13px; min-height:70px; }
    .runner-progress { margin-top:10px; font-size:13px; color:#454b6c; }
    .runner-flow { margin-top:14px; display:flex; flex-direction:column; gap:8px; }
    .runner-step { border:1px solid #e1e5f7; border-radius:10px; padding:10px 12px; background:#fdfdff; display:flex; justify-content:space-between; gap:10px; align-items:flex-start; }
    .runner-step .step-main { flex:1; }
    .runner-step .step-phase { font-size:11px; letter-spacing:0.08em; text-transform:uppercase; color:#7a82a5; margin-bottom:2px; }
    .runner-step .step-title { font-weight:600; color:#131a39; font-size:14px; }
    .runner-step .step-meta { font-size:12px; color:#505572; margin-top:4px; }
    .runner-step .step-progress { font-size:12px; font-weight:600; color:#2b3460; }
    .runner-step.completed { opacity:0.55; }
    .runner-step.active { border-color:#0b72ff; background:#eef4ff; box-shadow:0 0 0 1px rgba(11,114,255,0.2); }
    .runner-step.warmup .step-phase { color:#b25c00; }
    .runner-step.warmup.completed { display:none; }
    .runner-step.warmup.warmup-hidden { display:none; }
  </style>
  <link rel="stylesheet" href="/nav.css" />
  <script src="/common.js"></script>
</head>
<body data-page="execute">

<nav class="global-nav" data-global-nav></nav>

<div class="active-profile">
  Aktiv profil: <strong data-active-profile-label>Indlæser…</strong>
</div>

<h1>Eksekvering af program</h1>
<p class="muted">
  Vælg uge, dag og tilgængelig tid – så justeres sættene automatisk for at matche tidsbudgettet og dine registrerede RM-tal.
</p>

<section id="emptyState" class="">
  <h2>Intet blueprint fundet</h2>
  <p>
    Vi kunne ikke finde et aktivt blueprint for profilen
    <strong data-empty-profile>ukendt</strong>. Hop til
    <a href="/program">Programbyggeren</a> og gem et program eller brug
    <a href="/programs">Programarkivet</a> til at aktivere et tidligere blueprint.
  </p>
</section>

<div id="executionPanel" class="hidden">
  <div class="layout">
    <div>
      <section>
        <h2>Planvalg</h2>
        <div class="control-grid">
          <div>
            <label for="weekSelect">Uge</label>
            <select id="weekSelect"></select>
          </div>
          <div>
            <label for="timeInput">Tilgængelig tid (minutter)</label>
            <div class="time-control">
              <input type="number" id="timeInput" min="20" max="120" step="5" />
              <input type="range" id="timeSlider" min="20" max="120" step="5" />
            </div>
          </div>
        </div>
        <div class="session-note" id="sessionSummary">Vælg en dag for at se plan.</div>
        <div class="session-buttons" id="sessionButtons"></div>
      </section>

      <section>
        <h2 id="sessionTitle">Session</h2>
        <div class="warmup-banner">
          <strong>Fast opvarmning</strong>
          <span>Der er altid indlagt 10 minutters generel opvarmning før programmet.</span>
        </div>
        <div class="warmup-plan" id="warmupPlan">
          <strong>Opvarmningsforslag:</strong>
          <p class="muted">Indlæser øvelser…</p>
        </div>
        <table>
          <thead>
            <tr>
              <th>Øvelse</th>
              <th>Sæt × Reps</th>
              <th>Forslag (kg)</th>
              <th>Est. tid</th>
              <th>Pauser</th>
              <th>Noter</th>
            </tr>
          </thead>
          <tbody id="planRows">
            <tr><td colspan="6">Vælg dag…</td></tr>
          </tbody>
        </table>
        <div class="time-status" id="timeStatus"></div>
        <div>
          <strong>Justeringer</strong>
          <ul class="notes-list" id="adjustNotes"></ul>
        </div>
      </section>

      <section class="runner-section">
        <h2>Session Runner</h2>
        <div class="runner-status">
          <div id="runnerStatusText">Tryk “Start helt nyt” for at køre programmet.</div>
          <div class="runner-timer" id="runnerTimer">00:00</div>
        </div>
        <div class="runner-progress" id="runnerProgress"></div>
        <div class="runner-controls">
          <button id="startRunnerBtn">Start session</button>
          <button id="completeSetBtn" disabled>Markér sæt udført</button>
          <button id="skipRestBtn" disabled>Spring pause over</button>
          <button id="stopRunnerBtn" disabled>Afbryd</button>
          <button id="completePlannedBtn">Program gennemført som planlagt</button>
        </div>
        <p class="muted" id="runnerAutoNote">
          Sæt markeres automatisk med planlagte reps/vægte. Giv samlet feedback under evalueringen, og justér evt. programmet i builderen bagefter.
        </p>
        <div class="runner-flow" id="runnerFlow"></div>
        <div class="runner-eval hidden" id="runnerEval">
          <label>Overordnet rating (1-10)
            <input type="number" id="evalRating" min="1" max="10" />
          </label>
          <label>Opsummering / noter
            <textarea id="evalNotes" placeholder="Hvordan gik paset?"></textarea>
          </label>
          <button type="button" id="evalSaveBtn">Gem træningslog</button>
        </div>
      </section>
    </div>

    <aside class="summary" id="blueprintSummary">
      <h2>Blueprint</h2>
      <p>Indlæser…</p>
    </aside>
  </div>
</div>

<script>
const {
  ensureActiveProfileId,
  updateActiveProfileBadge,
  syncActiveProfileMeta,
  getStoredProfileId,
  getStoredProfileLabel,
  withProfileParam,
  setActiveProfileMeta,
  renderNavigation,
} = window.AppState;

ensureActiveProfileId();
renderNavigation("execute");
updateActiveProfileBadge();
syncActiveProfileMeta();

const SESSION_TEMPLATES = {
  upper_lower: ["Upper A", "Lower A", "Upper B", "Lower B"],
  push_pull_legs: ["Push", "Pull", "Legs", "Push", "Pull", "Legs"],
  full_body: ["Full body A", "Full body B", "Full body C"],
  power4: ["ME Upper", "ME Lower", "DE Upper", "DE Lower"],
  full_power: ["Full A", "Full B", "Full C"],
  polar4: ["Zone 2", "Intervals", "Zone 2 Long", "Threshold"],
  tri_split: ["Swim", "Bike", "Run", "Brick"],
};

const EXECUTION_PRESETS = {
  hypertrophy: {
    label: "Hypertrofi",
    defaultMinutes: 65,
    repText: { compound: "6-10 reps", isolation: "10-15 reps", default: "8-12 reps" },
    targetReps: { compound: 8, isolation: 12, default: 10 },
    baseSets: { compound: 4, isolation: 3, default: 3 },
    minSets: { compound: 2, isolation: 1, default: 1 },
    minutesPerSet: { compound: 3.5, isolation: 2.5, default: 3 },
    loadPct: { compound: 0.72, isolation: 0.65, default: 0.7 },
  },
  strength: {
    label: "Maksimal styrke",
    defaultMinutes: 70,
    repText: { compound: "3-5 reps", isolation: "8-10 reps", default: "3-5 reps" },
    targetReps: { compound: 4, isolation: 8, default: 4 },
    baseSets: { compound: 5, isolation: 3, default: 4 },
    minSets: { compound: 3, isolation: 1, default: 2 },
    minutesPerSet: { compound: 4, isolation: 3, default: 3.5 },
    loadPct: { compound: 0.87, isolation: 0.7, default: 0.8 },
  },
  conditioning: {
    label: "Kondition",
    defaultMinutes: 55,
    repText: { default: "Tidsblok / intervaller" },
    targetReps: { default: 12 },
    baseSets: { default: 4 },
    minSets: { default: 1 },
    minutesPerSet: { default: 3 },
    loadPct: { default: 0.6 },
  },
  default: {
    label: "Generel",
    defaultMinutes: 60,
    repText: { default: "8-12 reps" },
    targetReps: { default: 10 },
    baseSets: { default: 3 },
    minSets: { default: 1 },
    minutesPerSet: { default: 3 },
    loadPct: { default: 0.7 },
  },
};

const WARMUP_MINUTES = 10;
const REST_BETWEEN_EXERCISES = 15;
const DEFAULT_SET_REST = 15;

let blueprint = null;
let sessionLabels = [];
let rmRows = [];
let rmMap = {};
let currentSessionIndex = 0;
let currentWeek = 1;
let availableMinutes = 60;
let warmupCatalog = [];
let equipmentMap = {};
let currentPlanEntries = [];
let currentWarmupEntries = [];
const runnerState = {
  active: false,
  plan: [],
  exerciseIndex: 0,
  setIndex: 1,
  mode: "idle",
  restRemaining: 0,
  restType: "",
  startedAt: null,
  startIso: null,
  restEndTime: null,
};
let runnerTimerInterval = null;

initExecution();

async function initExecution() {
  updateActiveProfileBadge();
  currentSessionIndex = 0;
  currentWeek = 1;
  blueprint = await fetchBlueprintFromServer();
  if (blueprint) {
    persistLocalBlueprint(blueprint);
  } else {
    blueprint = loadBlueprintFromLocal();
  }

  if (!blueprint) {
    const emptyLabelEl = document.querySelector("[data-empty-profile]");
    if (emptyLabelEl) {
      emptyLabelEl.textContent = getStoredProfileLabel();
    }
    document.getElementById("emptyState").classList.remove("hidden");
    document.getElementById("executionPanel").classList.add("hidden");
    return;
  }

  const preset = getPreset();
  availableMinutes = preset.defaultMinutes;
  sessionLabels = getSessionLabels();

  setupWeekSelect();
  setupSessionButtons();
  setupTimeControls();
  renderBlueprintSummary();

  document.getElementById("emptyState").classList.add("hidden");
  document.getElementById("executionPanel").classList.remove("hidden");

  Promise.all([loadRmData(), loadWarmupData(), loadEquipmentCatalog()])
    .then(() => {
      renderPlan();
    })
    .catch(() => renderPlan());
}

function loadBlueprintFromLocal() {
  try {
    const profileId = getStoredProfileId();
    const raw = localStorage.getItem(`programBlueprint_${profileId}`);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function getPreset() {
  return EXECUTION_PRESETS[blueprint?.goal] || EXECUTION_PRESETS.default;
}

function getSessionLabels() {
  if (!blueprint?.structure) return ["Session A", "Session B"];
  const labels = SESSION_TEMPLATES[blueprint.structure];
  if (Array.isArray(labels) && labels.length) return labels;
  return ["Session A", "Session B"];
}

function setupWeekSelect() {
  const select = document.getElementById("weekSelect");
  const weeks = getStructureWeeks();
  const options = [];
  for (let i = 1; i <= weeks; i++) {
    options.push(`<option value="${i}">Uge ${i}</option>`);
  }
  select.innerHTML = options.join("");
  select.value = "1";
  select.onchange = () => {
    currentWeek = Number(select.value) || 1;
    renderPlan();
  };
}

function setupSessionButtons() {
  const container = document.getElementById("sessionButtons");
  container.innerHTML = sessionLabels
    .map((label, idx) => `<button type="button" data-session="${idx}">${label}</button>`)
    .join("");
  container.onclick = (event) => {
    if (!event.target.dataset.session) return;
    currentSessionIndex = Number(event.target.dataset.session);
    updateSessionButtonState();
    renderPlan();
  };
  updateSessionButtonState();
}

function updateSessionButtonState() {
  document.querySelectorAll("#sessionButtons button").forEach((btn) => {
    btn.classList.toggle("active", Number(btn.dataset.session) === currentSessionIndex);
  });
}

function setupTimeControls() {
  const input = document.getElementById("timeInput");
  const slider = document.getElementById("timeSlider");
  input.value = availableMinutes;
  slider.value = availableMinutes;
  input.oninput = () => {
    availableMinutes = Number(input.value) || 45;
    slider.value = availableMinutes;
    renderPlan();
  };
  slider.oninput = () => {
    availableMinutes = Number(slider.value) || 45;
    input.value = availableMinutes;
    renderPlan();
  };
}

async function loadRmData() {
  const res = await fetch(withProfileParam("/api/rm"));
  if (!res.ok) throw new Error("HTTP " + res.status);
  rmRows = await res.json();
  rmMap = {};
  rmRows.forEach((row) => {
    rmMap[row.exerciseKey] = row;
  });
}

async function loadWarmupData() {
  try {
    const res = await fetch("/api/warmup");
    if (!res.ok) throw new Error("HTTP " + res.status);
    warmupCatalog = await res.json();
  } catch (err) {
    console.warn("Kunne ikke hente opvarmningsøvelser", err);
    warmupCatalog = [];
  }
}

async function loadEquipmentCatalog() {
  try {
    const res = await fetch("/api/equipment");
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();
    equipmentMap = {};
    data.forEach((item) => {
      equipmentMap[item.key] = item.label || item.key;
    });
  } catch (err) {
    console.warn("Kunne ikke hente udstyr", err);
    equipmentMap = {};
  }
}

function getStructureWeeks() {
  const goal = blueprint?.goal && GOAL_STRUCTURES[blueprint.goal];
  if (goal) {
    const struct = goal.structures.find((s) => s.key === blueprint.structure);
    if (struct?.weeks) return struct.weeks;
  }
  return 12;
}

const GOAL_STRUCTURES = {
  hypertrophy: {
    structures: [
      { key: "upper_lower", weeks: 12 },
      { key: "push_pull_legs", weeks: 12 },
      { key: "full_body", weeks: 12 },
    ],
  },
  strength: {
    structures: [
      { key: "power4", weeks: 12 },
      { key: "full_power", weeks: 12 },
    ],
  },
  conditioning: {
    structures: [
      { key: "polar4", weeks: 12 },
      { key: "tri_split", weeks: 12 },
    ],
  },
};

function defaultSessionRestBetweenSets(entry) {
  const type = entry?.type || "";
  if (type === "compound") return 120;
  if (type === "isolation") return 60;
  return 75;
}

function defaultSessionRestBetweenExercises(entry) {
  const type = entry?.type || "";
  if (type === "compound") return 45;
  if (type === "isolation") return 30;
  return 30;
}

function ensureSessionExerciseFields(entry) {
  if (!entry || typeof entry !== "object") return { restBetweenSets: 90, restBetweenExercises: 30 };
  if (entry.restBetweenSets === undefined || entry.restBetweenSets === null) {
    entry.restBetweenSets = defaultSessionRestBetweenSets(entry);
  }
  if (entry.restBetweenExercises === undefined || entry.restBetweenExercises === null) {
    entry.restBetweenExercises = defaultSessionRestBetweenExercises(entry);
  }
  entry.restBetweenSets = Number(entry.restBetweenSets) || 0;
  entry.restBetweenExercises = Number(entry.restBetweenExercises) || 0;
  entry.supersetWithNext = Boolean(entry.supersetWithNext);
  return entry;
}

async function fetchBlueprintFromServer() {
  try {
    const res = await fetch(withProfileParam("/api/program-blueprint"));
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();
    if (data?.profileId && data?.profileLabel) {
      setActiveProfileMeta(data.profileId, data.profileLabel);
      updateActiveProfileBadge();
    }
    return data?.blueprint || null;
  } catch (err) {
    console.warn("Kunne ikke hente blueprint fra server", err);
    return null;
  }
}

function persistLocalBlueprint(bp) {
  try {
    const profileId = getStoredProfileId();
    localStorage.setItem(`programBlueprint_${profileId}`, JSON.stringify(bp));
  } catch {
    // ignore
  }
}

function renderBlueprintSummary() {
  const summary = document.getElementById("blueprintSummary");
  const preset = getPreset();
  const goalLabel = preset.label;
  const structureLabel = sessionLabels.length ? blueprint.structure : "Ukendt";
  const profileLabel = getStoredProfileLabel();
  const programName = blueprint?.programName || "Ukendt program";

  const list = [
    `<li><strong>Aktivt program:</strong> ${programName}</li>`,
    `<li><strong>Profil:</strong> ${profileLabel}</li>`,
    `<li><strong>Mål:</strong> ${goalLabel}</li>`,
    `<li><strong>Struktur:</strong> ${structureLabel}</li>`,
    `<li><strong>Uger:</strong> ${getStructureWeeks()}</li>`,
    `<li><strong>Default tid (program):</strong> ${preset.defaultMinutes} min</li>`,
    `<li><strong>Fast opvarmning:</strong> ${WARMUP_MINUTES} min ekstra</li>`,
  ];

  summary.innerHTML = `
    <h2>Blueprint</h2>
    <p>${goalLabel}</p>
    <ul>${list.join("")}</ul>
    <p class="muted">Blueprint gemt: ${formatDate(blueprint.savedAt)}</p>
  `;
}

function formatDate(value) {
  if (!value) return "ukendt";
  try {
    const d = new Date(value);
    return d.toLocaleString("da-DK", { dateStyle: "medium", timeStyle: "short" });
  } catch {
    return value;
  }
}

function renderPlan() {
  if (!blueprint) return;
  const basePlan = buildBasePlan(currentSessionIndex);
  const adjusted = adjustPlanForTime(basePlan, availableMinutes);
  currentPlanEntries = adjusted.plan.map((item) => ({ ...item }));
  renderPlanTable(currentPlanEntries);
  updateTimeStatus(basePlan, adjusted);
  renderAdjustmentNotes(adjusted.notes);
  renderSessionSummary();
  renderWarmupPlan();
  renderRunnerFlow();
  updateRunnerButtons();
}

function buildBasePlan(index) {
  const preset = getPreset();
  const sessionData = (blueprint.sessions && blueprint.sessions[index]) || {};
  let exercises = Array.isArray(sessionData.exercises) ? sessionData.exercises : [];
  if (!exercises.length) {
    exercises = rmRows.slice(0, 4).map((row) => ({
      exerciseKey: row.exerciseKey,
      name: row.name,
      type: row.type,
    }));
  }
  return exercises.map((ex, exIndex) => {
    const sessionEntry = ensureSessionExerciseFields(ex);
    const rmRow = rmMap[ex.exerciseKey];
    const type = ex.type || rmRow?.type || inferTypeFromTags(rmRow);
    const sets = pickPresetValue(preset.baseSets, type);
    const repsText = pickPresetValue(preset.repText, type);
    const targetReps = pickPresetValue(preset.targetReps, type);
    const workMinutesPerSet = pickPresetValue(preset.minutesPerSet, type);
    const minSets = pickPresetValue(preset.minSets, type);
    const loadPct = pickPresetValue(preset.loadPct, type);
    const restBetweenSetsSec = Number(sessionEntry.restBetweenSets) || defaultSessionRestBetweenSets(sessionEntry);
    const restBetweenExercisesSec =
      sessionEntry.supersetWithNext
        ? 0
        : Number(sessionEntry.restBetweenExercises) || defaultSessionRestBetweenExercises(sessionEntry);
    const minutesPerSet = workMinutesPerSet + restBetweenSetsSec / 60;
    const restBetweenExercisesMin = restBetweenExercisesSec / 60;
    return {
      name: ex.name || rmRow?.name || ex.exerciseKey,
      exerciseKey: ex.exerciseKey,
      type: type || "compound",
      sets,
      minSets,
      repsText,
      targetReps,
      minutesPerSet,
      workMinutesPerSet,
      loadSuggestion: formatLoadSuggestion(rmRow, targetReps, loadPct),
      estimatedMinutes: sets * minutesPerSet + restBetweenExercisesMin,
      restBetweenSetsSec,
      restBetweenExercisesSec,
      restBetweenExercisesMin,
      supersetWithNext: Boolean(sessionEntry.supersetWithNext),
      sessionExerciseIndex: exIndex,
      note: rmRow?.metricTypes ? metricNote(rmRow.metricTypes) : "",
      rmAvailable: Boolean(rmRow),
    };
  });
}

function pickPresetValue(presetSection, type) {
  if (!presetSection) return undefined;
  if (type && presetSection[type] !== undefined) return presetSection[type];
  return presetSection.default !== undefined ? presetSection.default : Object.values(presetSection)[0];
}

function inferTypeFromTags(row) {
  if (!row?.type && Array.isArray(row?.muscleGroups)) {
    return row.muscleGroups.length > 1 ? "compound" : "isolation";
  }
  return row?.type || "compound";
}

function metricNote(metricTypes) {
  if (metricTypes.count && metricTypes.time) return "Track tid og antal i RM";
  if (metricTypes.count) return "Track max reps";
  if (metricTypes.time) return "Track max tid";
  return "";
}

function formatLoadSuggestion(row, reps, pct) {
  if (!row) return "Brug RPE 7-8";
  const rmData = row.rm;
  const percent = pct || 0.7;
  if (rmData) {
    const oneRM = rmData["1"];
    if (typeof oneRM === "number") {
      const load = roundLoad(oneRM * percent);
      return `${load} kg (~${Math.round(percent * 100)}% af 1RM)`;
    }
    const available = Object.keys(rmData);
    if (available.length) {
      const desired = Number(reps) || 8;
      let bestKey = available[0];
      let bestDiff = Math.abs(Number(bestKey) - desired);
      for (const key of available) {
        const diff = Math.abs(Number(key) - desired);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestKey = key;
        }
      }
      const value = rmData[bestKey];
      if (typeof value === "number") {
        return `${value} kg (@${bestKey}RM)`;
      }
    }
  }

  const metrics = row.metrics || {};
  const types = row.metricTypes || {};
  const metricPct = pctToPercent(pct);
  if (types.count && typeof metrics.count === "number") {
    const rec = Math.max(1, Math.round(metrics.count * metricPct));
    return `${rec} reps (~${Math.round(metricPct * 100)}% af max ${metrics.count})`;
  }
  if (types.time && typeof metrics.time === "number") {
    const seconds = Math.max(5, Math.round(metrics.time * metricPct));
    return `${seconds} sek (~${Math.round(metricPct * 100)}% af max ${metrics.time} sek)`;
  }

  if (types.count && types.time) {
    return "Brug seneste max tid/reps fra RM-siden";
  }
  if (types.count) {
    return "Brug seneste max reps (kropsvægt)";
  }
  if (types.time) {
    return "Arbejd efter max tid fra RM-siden";
  }

  return "Brug RPE 7-8";
}

function pctToPercent(value) {
  if (!value && value !== 0) return 0.7;
  return Number(value);
}

function roundLoad(value) {
  return Math.round((value || 0) / 0.5) * 0.5;
}

function parseLoadValue(text) {
  if (!text) return null;
  const match = String(text).match(/([\d.,]+)\s*kg/i);
  if (!match) return null;
  const normalized = match[1].replace(",", ".");
  const value = Number(normalized);
  return Number.isFinite(value) ? value : null;
}

function adjustPlanForTime(plan, minutesAvailable) {
  const adjusted = plan.map((item) => ({ ...item }));
  const notes = [];
  let total = estimateTotalMinutes(adjusted);
  const target = Number(minutesAvailable) || total;

  if (total <= target) {
    return { plan: adjusted, totalMinutes: total, notes };
  }

  const order = adjusted
    .map((item, idx) => ({ idx, priority: item.type === "isolation" ? 1 : 2 }))
    .sort((a, b) => a.priority - b.priority);

  for (const candidate of order) {
    const entry = adjusted[candidate.idx];
    while (entry.sets > entry.minSets && total > target) {
      entry.sets -= 1;
      total -= entry.minutesPerSet;
      notes.push(`Fjernede ét sæt fra ${entry.name}`);
    }
    if (total <= target) break;
  }

  if (total > target) {
    notes.push("Nåede ikke helt tidsmålet – overvej at fjerne en øvelse eller forhåndskort huller.");
  }

  return { plan: adjusted, totalMinutes: Math.max(total, 0), notes };
}

function estimateTotalMinutes(entries) {
  return entries.reduce((sum, item) => sum + item.sets * item.minutesPerSet + (item.restBetweenExercisesMin || 0), 0);
}

function renderPlanTable(entries) {
  const tbody = document.getElementById("planRows");
  if (!entries.length) {
    tbody.innerHTML = `<tr><td colspan="6">Ingen øvelser valgt på blueprintet endnu. Tilføj dem på <a href="/program">Programbyggeren</a>.</td></tr>`;
    return;
  }
  tbody.innerHTML = entries
    .map(
      (item, idx) => `
      <tr data-plan-index="${idx}">
        <td>${item.name}${item.rmAvailable ? "" : "<br><span class='warning'>Manglende RM-data</span>"}</td>
        <td>${item.sets} sæt · ${item.repsText}</td>
        <td>${item.loadSuggestion}</td>
        <td>${Math.round(item.sets * item.minutesPerSet + (item.restBetweenExercisesMin || 0))} min</td>
        <td>
          <div class="rest-editors">
            <label>Pause sæt (sek)
              <input type="number" min="0" step="5" value="${Math.round(item.restBetweenSetsSec || 0)}"
                     data-role="plan-rest-sets" data-plan-index="${idx}" />
            </label>
            <label>Pause mellem øvelser (sek)
              <input type="number" min="0" step="5" value="${Math.round(item.restBetweenExercisesSec || 0)}"
                     data-role="plan-rest-between" data-plan-index="${idx}" />
            </label>
          </div>
          ${item.supersetWithNext ? `<div class="superset-note">Supersæt med næste øvelse</div>` : ""}
        </td>
        <td>${item.note || ""}</td>
      </tr>
    `
    )
    .join("");
}

function updateTimeStatus(basePlan, adjusted) {
  const baseMinutes = estimateTotalMinutes(basePlan);
  const status = document.getElementById("timeStatus");
  const diff = Math.round((adjusted.totalMinutes - baseMinutes) * 10) / 10;
  const totalWithWarmup = adjusted.totalMinutes + WARMUP_MINUTES;
  status.innerHTML = `
    Opvarmning: ${WARMUP_MINUTES} min · Program (efter tilpasning): ${Math.round(adjusted.totalMinutes)} min ·
    Total: ${Math.round(totalWithWarmup)} min · Tilgængelig tid (program): ${availableMinutes} min
    ${diff !== 0 ? `<span class="badge">${diff > 0 ? "+" : ""}${diff} min vs. original</span>` : ""}
  `;
}

function renderAdjustmentNotes(notes) {
  const list = document.getElementById("adjustNotes");
  if (!notes.length) {
    list.innerHTML = "<li>Ingen automatisk trimming nødvendig.</li>";
    return;
  }
  list.innerHTML = notes.map((note) => `<li>${note}</li>`).join("");
}

function ensureBlueprintSession(index) {
  if (!blueprint.sessions) blueprint.sessions = [];
  if (!blueprint.sessions[index]) {
    blueprint.sessions[index] = { notes: "", exercises: [] };
  }
  if (!Array.isArray(blueprint.sessions[index].exercises)) {
    blueprint.sessions[index].exercises = [];
  }
  return blueprint.sessions[index];
}

function ensureBlueprintExerciseForPlan(planItem) {
  const session = ensureBlueprintSession(currentSessionIndex);
  const idx = planItem.sessionExerciseIndex ?? session.exercises.length;
  if (!session.exercises[idx]) {
    session.exercises[idx] = {
      exerciseKey: planItem.exerciseKey,
      name: planItem.name,
      type: planItem.type,
      equipment: planItem.equipment || [],
      muscleGroups: planItem.muscleGroups || [],
    };
  }
  return session.exercises[idx];
}

document.getElementById("planRows").addEventListener("input", (event) => {
  const role = event.target.dataset.role;
  if (role !== "plan-rest-sets" && role !== "plan-rest-between") return;
  const planIndex = Number(event.target.dataset.planIndex);
  if (!Number.isFinite(planIndex)) return;
  const planItem = currentPlanEntries[planIndex];
  if (!planItem) return;
  const value = Math.max(0, Number(event.target.value) || 0);
  const exercise = ensureBlueprintExerciseForPlan(planItem);
  if (role === "plan-rest-sets") {
    exercise.restBetweenSets = value;
  } else if (role === "plan-rest-between") {
    exercise.restBetweenExercises = value;
  }
  renderPlan();
});

function renderSessionSummary() {
  const title = document.getElementById("sessionTitle");
  const sessionName = sessionLabels[currentSessionIndex] || `Session ${currentSessionIndex + 1}`;
  title.textContent = `${sessionName} – uge ${currentWeek}`;
  const summary = document.getElementById("sessionSummary");
  const sessionData = (blueprint.sessions && blueprint.sessions[currentSessionIndex]) || {};
  const notes = sessionData.notes ? sessionData.notes.trim() : "";
  summary.textContent = notes ? notes : "Ingen noter for denne dag endnu.";
}

function renderWarmupPlan() {
  const container = document.getElementById("warmupPlan");
  if (!container) return;
  if (!warmupCatalog.length) {
    currentWarmupEntries = [];
    container.innerHTML = `<strong>Opvarmningsforslag:</strong>
      <p class="muted">Tilføj øvelser på <a href="/warmup">/warmup</a> for at få automatisk forslag.</p>`;
    return;
  }
  const planResult = buildWarmupPlan();
  const plan = planResult.items;
  if (!plan.length) {
    currentWarmupEntries = [];
    container.innerHTML = `<strong>Opvarmningsforslag:</strong>
      <p class="muted">Kunne ikke generere — tilføj flere øvelser.</p>`;
    return;
  }
  currentWarmupEntries = plan.map((item, idx) => ({
    ...item,
    uid: item.uid || item.id || item.key || `${item.name || "warmup"}_${idx}`,
    rounds: Math.max(1, item.rounds || 1),
  }));
  const listItems = plan
    .map((item) => {
      const detail = describeWarmupItem(item);
      const equip = formatWarmupEquipment(item.equipment);
      return `<li><strong>${item.name}</strong> — ${detail}${equip ? `<br><span class="warmup-equip">${equip}</span>` : ""}</li>`;
    })
    .join("");
  const totalSeconds = planResult.totalSeconds;
  container.innerHTML = `
    <strong>Opvarmningsforslag:</strong>
    <ul>${listItems}</ul>
    <p class="muted">
      Varighed ca. ${Math.round(totalSeconds / 60)} min (del af de 10 min). Vi justerer automatisk sæt/pauser for at lande tæt på 10 minutter – gentag planen hvis du har energi til mere.
    </p>
  `;
}

function describeWarmupItem(item) {
  const parts = [];
  if (item.reps) parts.push(`${item.reps} reps`);
  if (item.timeSeconds) parts.push(`${item.timeSeconds} sek`);
  if (item.durationSeconds) parts.push(`${Math.round(item.durationSeconds / 60)} min`);
  const sets = item.sets && item.sets > 1 ? `${item.sets} sæt` : null;
  if (sets) parts.push(sets);
  if (item.note) parts.push(item.note);
  if (!parts.length) return "Arbejd i eget tempo";
  return parts.join(" · ");
}

function formatWarmupEquipment(list) {
  if (!Array.isArray(list) || !list.length) return "";
  return list
    .map((key) => equipmentMap[key] || key)
    .filter(Boolean)
    .join(", ");
}

function buildWarmupPlan(targetMinutes = WARMUP_MINUTES) {
  if (!warmupCatalog.length) return { items: [], totalSeconds: 0 };
  const shuffled = [...warmupCatalog].sort(() => Math.random() - 0.5);
  const targetSeconds = targetMinutes * 60;
  const plan = [];
  let totalSeconds = 0;

  for (const entry of shuffled) {
    const baseSeconds = estimateWarmupSeconds(entry);
    if (!baseSeconds) continue;
    const restBetween = plan.length ? REST_BETWEEN_EXERCISES : 0;
    plan.push({ ...entry, seconds: baseSeconds });
    totalSeconds += baseSeconds + restBetween;
    if (totalSeconds >= targetSeconds * 0.6) break;
  }

  if (!plan.length) return { items: [], totalSeconds: 0 };

  let round = 1;
  while (totalSeconds < targetSeconds && round < 4) {
    for (const item of plan) {
      const restBetween = REST_BETWEEN_EXERCISES;
      totalSeconds += item.seconds + restBetween;
      item.rounds = (item.rounds || 1) + 1;
      if (totalSeconds >= targetSeconds) break;
    }
    round += 1;
  }

  plan.forEach((item) => {
    const rounds = item.rounds || 1;
    if (rounds > 1) item.note = `Gentag ${rounds} runder`;
  });

  return { items: plan, totalSeconds };
}

function estimateWarmupSeconds(entry) {
  const perSet = Number.isFinite(entry.durationSeconds)
    ? entry.durationSeconds
    : Number.isFinite(entry.timeSeconds)
    ? entry.timeSeconds
    : Number.isFinite(entry.reps)
    ? entry.reps * 3
    : 60;
  const sets = entry.sets && entry.sets > 0 ? entry.sets : 1;
  const rest = Number.isFinite(entry.restSeconds) ? entry.restSeconds : DEFAULT_SET_REST;
  return sets * perSet + (sets > 1 ? (sets - 1) * rest : 0);
}

function buildRunnerExecutionPlan() {
  const plan = [];
  const warmupBase = currentWarmupEntries.map((item, idx) => ({
    item,
    idx,
    rounds: Math.max(1, item.rounds || 1),
    setsPerRound: Math.max(1, item.sets || 1),
    detail: describeWarmupItem(item),
  }));
  const maxRounds = warmupBase.length ? warmupBase.reduce((max, entry) => Math.max(max, entry.rounds), 1) : 0;
  for (let round = 1; round <= maxRounds; round++) {
    warmupBase.forEach(({ item, idx, rounds, setsPerRound, detail }) => {
      if (round > rounds) return;
      const title = rounds > 1 ? `${item.name || "Opvarmning"} – runde ${round}/${rounds}` : item.name || "Opvarmning";
      plan.push({
        phase: "warmup",
        name: title,
        exerciseKey: (item.uid ? `warmup:${item.uid}` : `warmup:${idx}`) + `:r${round}`,
        totalSets: setsPerRound,
        targetReps: item.reps || null,
        repsText: detail,
        warmupDetail: detail,
        loadSuggestion: formatWarmupLoadSuggestion(item),
        restBetweenSetsSec: Math.min(20, REST_BETWEEN_EXERCISES),
        restBetweenExercisesSec: REST_BETWEEN_EXERCISES,
        supersetWithNext: false,
        type: "warmup",
        note: item.note,
        completedSets: 0,
        feedback: [],
      });
    });
  }
  currentPlanEntries.forEach((item, idx) => {
    plan.push({
      phase: "session",
      name: item.name,
      exerciseKey: item.exerciseKey || `session_${idx}`,
      totalSets: item.sets || item.totalSets || 1,
      targetReps: item.targetReps,
      repsText: item.repsText,
      loadSuggestion: item.loadSuggestion,
      restBetweenSetsSec: item.restBetweenSetsSec || defaultSessionRestBetweenSets(item),
      restBetweenExercisesSec: item.restBetweenExercisesSec || defaultSessionRestBetweenExercises(item),
      supersetWithNext: item.supersetWithNext,
      type: item.type,
      note: item.note,
      completedSets: 0,
      feedback: [],
    });
  });
  for (let i = 0; i < plan.length; i++) {
    const entry = plan[i];
    if (entry.phase !== "session" || !entry.supersetWithNext) continue;
    const partner = plan[i + 1];
    if (!partner || partner.phase !== "session") continue;
    entry.supersetPartnerIndex = i + 1;
    partner.pairedWithPrev = true;
    partner.supersetLeadIndex = i;
  }
  return plan;
}

function formatWarmupLoadSuggestion(item) {
  if (Number.isFinite(item.timeSeconds)) return `${Math.round(item.timeSeconds)} sek pr. runde`;
  if (Number.isFinite(item.durationSeconds)) return `${Math.round(item.durationSeconds / 60)} min pr. øvelse`;
  if (Number.isFinite(item.seconds)) return `${Math.round(item.seconds)} sek pr. øvelse`;
  return "";
}

function getRunnerPlanPreview() {
  if (runnerState.active || runnerState.mode === "complete") {
    return runnerState.plan;
  }
  return buildRunnerExecutionPlan();
}

function formatRunnerStepMeta(entry) {
  if (entry.phase === "warmup") {
    const bits = [entry.warmupDetail || entry.repsText];
    if (entry.loadSuggestion) bits.push(entry.loadSuggestion);
    return bits.filter(Boolean).join(" · ") || "Let opvarmning";
  }
  const total = entry.totalSets || entry.sets || 1;
  const bits = [`${total} sæt${entry.repsText ? ` · ${entry.repsText}` : ""}`];
  if (entry.loadSuggestion) bits.push(entry.loadSuggestion);
  if (entry.note) bits.push(entry.note);
  if (entry.supersetWithNext) bits.push("Supersæt – fortsæt direkte til næste");
  if (entry.pairedWithPrev) bits.push("Supersæt – del af forrige øvelse");
  return bits.filter(Boolean).join(" · ");
}

function formatRunnerStepProgress(entry) {
  const total = Math.max(1, entry.totalSets || entry.sets || 1);
  const completed = Math.min(entry.completedSets || 0, total);
  const label = entry.phase === "warmup" ? "runder" : "sæt";
  return `${completed}/${total} ${label}`;
}

function getRunnerStepStatus(index) {
  if (runnerState.mode === "complete") return "completed";
  if (!runnerState.active) return "";
  if (runnerState.mode === "rest_exercise") {
    if (index <= runnerState.exerciseIndex) return "completed";
    if (index === runnerState.exerciseIndex + 1 && runnerState.exerciseIndex + 1 < runnerState.plan.length) {
      return "active";
    }
    return "";
  }
  if (index < runnerState.exerciseIndex) return "completed";
  if (index === runnerState.exerciseIndex) return "active";
  return "";
}

function renderRunnerFlow() {
  const container = runnerElements.flow || document.getElementById("runnerFlow");
  if (!container) return;
  const plan = getRunnerPlanPreview();
  if (!plan.length) {
    container.innerHTML = `<p class="muted">Ingen øvelser klar endnu – vælg uge og dag.</p>`;
    return;
  }
  const html = plan
    .map((entry, idx) => {
      const status = getRunnerStepStatus(idx);
      const classes = ["runner-step", entry.phase === "warmup" ? "warmup" : "session"];
      if (status) classes.push(status);
      if (runnerState.active && entry.phase === "warmup" && status !== "active") {
        classes.push("warmup-hidden");
      }
      return `
        <div class="${classes.join(" ")}" data-step-index="${idx}">
          <div class="step-main">
            <div class="step-phase">${entry.phase === "warmup" ? "Opvarmning" : "Session"}</div>
            <div class="step-title">${entry.name || ""}</div>
            <div class="step-meta">${formatRunnerStepMeta(entry)}</div>
          </div>
          <div class="step-progress">${formatRunnerStepProgress(entry)}</div>
        </div>
      `;
    })
    .join("");
  container.innerHTML = html;
}

function formatTimer(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
}

const runnerElements = {
  statusText: document.getElementById("runnerStatusText"),
  timer: document.getElementById("runnerTimer"),
  progress: document.getElementById("runnerProgress"),
  flow: document.getElementById("runnerFlow"),
  startBtn: document.getElementById("startRunnerBtn"),
  completeBtn: document.getElementById("completeSetBtn"),
  skipBtn: document.getElementById("skipRestBtn"),
  stopBtn: document.getElementById("stopRunnerBtn"),
  completePlanBtn: document.getElementById("completePlannedBtn"),
  evalBox: document.getElementById("runnerEval"),
  evalRating: document.getElementById("evalRating"),
  evalNotes: document.getElementById("evalNotes"),
  evalSave: document.getElementById("evalSaveBtn"),
};

function updateRunnerButtons() {
  const hasPlan = currentPlanEntries.length > 0;
  if (!runnerElements.startBtn) return;
  runnerElements.startBtn.disabled = runnerState.active || !hasPlan;
  runnerElements.completeBtn.disabled = !runnerState.active || runnerState.mode !== "work";
  const resting = runnerState.mode === "rest_set" || runnerState.mode === "rest_exercise";
  runnerElements.skipBtn.disabled = !runnerState.active || !resting;
  runnerElements.stopBtn.disabled = !runnerState.active;
  if (runnerElements.completePlanBtn) {
    runnerElements.completePlanBtn.disabled = runnerState.active || !hasPlan;
  }
}

function disablePlanControls(flag) {
  const weekSelect = document.getElementById("weekSelect");
  const timeInput = document.getElementById("timeInput");
  const timeSlider = document.getElementById("timeSlider");
  if (weekSelect) weekSelect.disabled = flag;
  if (timeInput) timeInput.disabled = flag;
  if (timeSlider) timeSlider.disabled = flag;
}

function updateRunnerStatus() {
  if (!runnerElements.statusText) return;
  if (!runnerState.active && runnerState.mode !== "complete") {
    runnerElements.statusText.textContent = currentPlanEntries.length
      ? "Klar til at starte sessionen"
      : "Planen er tom – vælg først mål og session.";
    runnerElements.progress.textContent = "";
    runnerElements.timer.textContent = "00:00";
     renderRunnerFlow();
    return;
  }
  const elapsed = runnerState.startedAt ? Math.floor((Date.now() - runnerState.startedAt) / 1000) : 0;
  runnerElements.timer.textContent = formatTimer(elapsed);
  if (runnerState.mode === "complete") {
    runnerElements.statusText.textContent = "Session gennemført – udfyld evaluering";
    runnerElements.progress.textContent = "";
    renderRunnerFlow();
    return;
  }
  const exercise = runnerState.plan[runnerState.exerciseIndex];
  if (!exercise) {
    runnerElements.statusText.textContent = "Session afsluttet";
    runnerElements.progress.textContent = "";
    renderRunnerFlow();
    return;
  }
  runnerState.setIndex = Math.min((exercise.completedSets || 0) + 1, exercise.totalSets || 1);
  const phaseLabel = exercise.phase === "warmup" ? "Opvarmning" : "Øvelse";
  const unitLabel = exercise.phase === "warmup" ? "runde" : "sæt";
  if (runnerState.mode === "rest_set") {
    runnerElements.statusText.textContent = `Pause mellem ${unitLabel} – ${exercise.name}`;
  } else if (runnerState.mode === "rest_exercise") {
    const nextEntry = runnerState.plan[runnerState.exerciseIndex + 1];
    const nextLabel = nextEntry ? (nextEntry.phase === "warmup" ? "opvarmning" : "øvelse") : "afslut";
    runnerElements.statusText.textContent = `Pause mellem øvelser – næste: ${
      nextEntry ? `${nextEntry.name} (${nextLabel})` : "afslut"
    }`;
  } else {
    runnerElements.statusText.textContent = `${phaseLabel}: ${exercise.name} · ${unitLabel} ${runnerState.setIndex}/${exercise.totalSets}`;
  }
  const restInfo =
    runnerState.restRemaining && (runnerState.mode === "rest_set" || runnerState.mode === "rest_exercise")
      ? ` · ${runnerState.restRemaining}s pause`
      : "";
  runnerElements.progress.textContent = `${phaseLabel} ${Math.min(
    runnerState.exerciseIndex + 1,
    runnerState.plan.length
  )}/${runnerState.plan.length}${restInfo}`;
  renderRunnerFlow();
}

function startSessionRunner() {
  const runnerPlan = buildRunnerExecutionPlan();
  if (!runnerPlan.length) {
    alert("Planen er tom. Vælg mål/uge først.");
    return;
  }
  runnerState.active = true;
  runnerState.plan = runnerPlan.map((item) => ({
    ...item,
    totalSets: Math.max(1, item.totalSets || 1),
    completedSets: 0,
    feedback: [],
  }));
  runnerState.exerciseIndex = 0;
  runnerState.setIndex = 1;
  runnerState.mode = "work";
  runnerState.startedAt = Date.now();
  runnerState.startIso = new Date().toISOString();
  runnerState.restRemaining = 0;
  runnerState.restEndTime = null;
  runnerElements.evalBox.classList.add("hidden");
  disablePlanControls(true);
  startRunnerTimer();
  updateRunnerStatus();
  updateRunnerButtons();
}

function startRunnerTimer() {
  if (runnerTimerInterval) clearInterval(runnerTimerInterval);
  runnerTimerInterval = setInterval(() => {
    if (!runnerState.active && runnerState.mode !== "complete") return;
    updateRunnerStatus();
    if (
      runnerState.restEndTime &&
      (runnerState.mode === "rest_set" || runnerState.mode === "rest_exercise")
    ) {
      const remaining = Math.max(0, Math.round((runnerState.restEndTime - Date.now()) / 1000));
      runnerState.restRemaining = remaining;
      if (remaining <= 0) {
        runnerState.restEndTime = null;
        advanceToNextWork();
      }
    }
  }, 1000);
}

function handleCompleteSetClick() {
  if (!runnerState.active || runnerState.mode !== "work") return;
  autoRecordCurrentSet();
  advanceAfterSet();
  updateRunnerStatus();
  updateRunnerButtons();
}

function autoRecordCurrentSet() {
  const exercise = runnerState.plan[runnerState.exerciseIndex];
  if (!exercise) return;
  const noteParts = [];
  if (exercise.repsText) noteParts.push(exercise.repsText);
  if (exercise.loadSuggestion) noteParts.push(exercise.loadSuggestion);
  exercise.feedback.push({
    set: runnerState.setIndex,
    reps: exercise.targetReps || null,
    weight: parseLoadValue(exercise.loadSuggestion),
    notes: noteParts.length ? `Plan: ${noteParts.join(" · ")}` : "Planlagte værdier",
    timestamp: new Date().toISOString(),
    auto: true,
  });
}

function buildPlanFeedbackEntries(exercise) {
  const entries = [];
  const total = Math.max(1, exercise.totalSets || exercise.sets || 1);
  const noteParts = [];
  if (exercise.phase === "warmup") {
    if (exercise.warmupDetail) noteParts.push(exercise.warmupDetail);
  } else {
    if (exercise.repsText) noteParts.push(exercise.repsText);
    if (exercise.loadSuggestion) noteParts.push(exercise.loadSuggestion);
  }
  for (let set = 1; set <= total; set++) {
    entries.push({
      set,
      reps: exercise.targetReps || null,
      weight: parseLoadValue(exercise.loadSuggestion),
      notes: noteParts.length ? `Plan: ${noteParts.join(" · ")}` : "Planlagte værdier",
      timestamp: new Date().toISOString(),
      auto: true,
    });
  }
  return entries;
}

function advanceAfterSet() {
  const exercise = runnerState.plan[runnerState.exerciseIndex];
  if (!exercise) return;
  exercise.completedSets = (exercise.completedSets || 0) + 1;
  if (runnerState.setIndex >= exercise.totalSets) {
    startRest("exercise", exercise.restBetweenExercisesSec || 0);
  } else {
    runnerState.setIndex += 1;
    startRest("set", exercise.restBetweenSetsSec || 0);
  }
}

function startRest(type, seconds) {
  runnerState.restRemaining = Math.max(0, Math.round(seconds || 0));
  runnerState.restEndTime =
    runnerState.restRemaining > 0 ? Date.now() + runnerState.restRemaining * 1000 : null;
  runnerState.mode = type === "exercise" ? "rest_exercise" : "rest_set";
  if (runnerState.restRemaining === 0) {
    advanceToNextWork();
  }
  updateRunnerStatus();
  updateRunnerButtons();
}

function advanceToNextWork() {
  if (runnerState.mode === "rest_set") {
    runnerState.mode = "work";
    updateRunnerStatus();
    updateRunnerButtons();
    return;
  }
  if (runnerState.mode === "rest_exercise") {
    runnerState.exerciseIndex += 1;
    if (runnerState.exerciseIndex >= runnerState.plan.length) {
      finishSessionRunner();
    } else {
      runnerState.setIndex = 1;
      runnerState.mode = "work";
      updateRunnerStatus();
      updateRunnerButtons();
    }
  }
}

function finishSessionRunner() {
  runnerState.active = false;
  runnerState.mode = "complete";
  if (runnerTimerInterval) {
    clearInterval(runnerTimerInterval);
    runnerTimerInterval = null;
  }
  updateRunnerStatus();
  updateRunnerButtons();
  disablePlanControls(false);
  runnerElements.evalBox.classList.remove("hidden");
}

function resetRunnerState() {
  runnerState.active = false;
  runnerState.plan = [];
  runnerState.exerciseIndex = 0;
  runnerState.setIndex = 1;
  runnerState.mode = "idle";
  runnerState.restRemaining = 0;
  runnerState.startedAt = null;
  runnerState.startIso = null;
  if (runnerTimerInterval) {
    clearInterval(runnerTimerInterval);
    runnerTimerInterval = null;
  }
  runnerElements.timer.textContent = "00:00";
  runnerElements.evalBox.classList.add("hidden");
  disablePlanControls(false);
  updateRunnerStatus();
  updateRunnerButtons();
}

function cancelRunner() {
  if (!runnerState.active) return;
  if (!window.confirm("Afbryd sessionen? Fremdrift logges ikke.")) return;
  resetRunnerState();
}

function skipCurrentRest() {
  if (runnerState.mode !== "rest_set" && runnerState.mode !== "rest_exercise") return;
  runnerState.restRemaining = 0;
  runnerState.restEndTime = null;
  advanceToNextWork();
}

function markPlanCompletedAutomatically() {
  if (runnerState.active) {
    alert("Stop først den igangværende session, eller fullfør den manuelt.");
    return;
  }
  if (!currentPlanEntries.length) {
    alert("Planen er tom. Vælg uge/dag først.");
    return;
  }
  const runnerPlan = buildRunnerExecutionPlan();
  if (!runnerPlan.length) {
    alert("Kunne ikke finde øvelser for sessionen.");
    return;
  }
  runnerPlan.forEach((entry) => {
    const total = Math.max(1, entry.totalSets || 1);
    entry.completedSets = total;
    entry.feedback = buildPlanFeedbackEntries(entry);
  });
  const estimatedSeconds = Math.max(
    600,
    Math.round((estimateTotalMinutes(currentPlanEntries) + WARMUP_MINUTES) * 60)
  );
  const now = Date.now();
  runnerState.active = false;
  runnerState.plan = runnerPlan;
  runnerState.exerciseIndex = runnerPlan.length - 1;
  runnerState.setIndex = runnerPlan[runnerPlan.length - 1]?.totalSets || 1;
  runnerState.mode = "complete";
  runnerState.startedAt = now - estimatedSeconds * 1000;
  runnerState.startIso = new Date(runnerState.startedAt).toISOString();
  runnerState.restRemaining = 0;
  runnerState.restEndTime = null;
  disablePlanControls(false);
  runnerElements.evalBox.classList.remove("hidden");
  renderRunnerFlow();
  updateRunnerStatus();
  updateRunnerButtons();
}

async function saveWorkoutLog() {
  const rating = runnerElements.evalRating.value ? Number(runnerElements.evalRating.value) : null;
  const notes = runnerElements.evalNotes.value.trim();
  const payload = {
    sessionLabel: sessionLabels[currentSessionIndex] || `Session ${currentSessionIndex + 1}`,
    week: currentWeek,
    goal: blueprint?.goal || null,
    structure: blueprint?.structure || null,
    programId: blueprint?.programId || null,
    startTime: runnerState.startIso || new Date().toISOString(),
    durationSeconds: runnerState.startedAt ? Math.round((Date.now() - runnerState.startedAt) / 1000) : 0,
    exercises: runnerState.plan.map((item) => ({
      exerciseKey: item.exerciseKey,
      name: item.name,
      plannedSets: item.totalSets,
      completedSets: Math.min(item.completedSets || item.feedback.length, item.totalSets),
      feedback: item.feedback,
      phase: item.phase || "session",
    })),
    notes,
    evaluation: { rating, comment: notes },
  };
  runnerElements.evalSave.disabled = true;
  try {
    const res = await fetch(withProfileParam("/api/workouts"), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    runnerElements.statusText.textContent = "Træningspas gemt ✅";
    runnerElements.evalBox.classList.add("hidden");
    runnerElements.evalNotes.value = "";
    runnerElements.evalRating.value = "";
    resetRunnerState();
  } catch (err) {
    console.error(err);
    runnerElements.statusText.textContent = "Kunne ikke gemme træningslog ❌";
  } finally {
    runnerElements.evalSave.disabled = false;
  }
}

runnerElements.startBtn.addEventListener("click", startSessionRunner);
runnerElements.completeBtn.addEventListener("click", handleCompleteSetClick);
runnerElements.skipBtn.addEventListener("click", skipCurrentRest);
runnerElements.stopBtn.addEventListener("click", cancelRunner);
if (runnerElements.completePlanBtn) {
  runnerElements.completePlanBtn.addEventListener("click", markPlanCompletedAutomatically);
}
runnerElements.evalSave.addEventListener("click", saveWorkoutLog);

if (runnerElements.flow) {
  runnerElements.flow.addEventListener("click", (event) => {
    const stepEl = event.target.closest("[data-step-index]");
    if (!stepEl) return;
    const idx = Number(stepEl.dataset.stepIndex);
    if (!Number.isFinite(idx)) return;
    if (!runnerState.active) return;
    if (runnerState.mode === "work" && idx === runnerState.exerciseIndex) {
      handleCompleteSetClick();
    } else if (
      (runnerState.mode === "rest_set" || runnerState.mode === "rest_exercise") &&
      idx === runnerState.exerciseIndex
    ) {
      skipCurrentRest();
    }
  });
}

document.addEventListener("keydown", (event) => {
  const tag = event.target?.tagName;
  if (tag && ["INPUT", "TEXTAREA", "SELECT"].includes(tag.toUpperCase())) return;
  if (!runnerState.active) return;
  if (event.code === "Space") {
    event.preventDefault();
    if (runnerState.mode === "work") {
      handleCompleteSetClick();
    } else if (runnerState.mode === "rest_set" || runnerState.mode === "rest_exercise") {
      skipCurrentRest();
    }
  } else if (event.code === "Enter") {
    event.preventDefault();
    if (runnerState.mode === "work") {
      handleCompleteSetClick();
    } else if (runnerState.mode === "rest_set" || runnerState.mode === "rest_exercise") {
      skipCurrentRest();
    }
  }
});

updateRunnerStatus();
updateRunnerButtons();
</script>
</script>

</body>
</html>
